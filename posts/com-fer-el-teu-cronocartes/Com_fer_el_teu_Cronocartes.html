<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-02-02">
<meta name="description" content="Apunts per crear la teva versió del joc de cartes històric Cronocartes">

<title>Com fer el teu Cronocartes – mgfernan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-J0Q5PFB35Q"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-J0Q5PFB35Q', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">mgfernan</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-jocs" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Jocs</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-jocs">    
        <li>
    <a class="dropdown-item" href="../../games/status.html">
 <span class="dropdown-text">Desenvolupament de jocs</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../games/cronocartes/index.html">
 <span class="dropdown-text">Cronocartes Història de Catalunya</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../games/cronocartas/index.html">
 <span class="dropdown-text">Cronocartas Historia de Galicia</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/mgfernan"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://instagram.com/cronocartes"> <i class="bi bi-instagram" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Com fer el teu Cronocartes</h1>
                  <div>
        <div class="description">
          Apunts per crear la teva versió del joc de cartes històric Cronocartes
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Jocs de taula</div>
                <div class="quarto-category">Català</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 2, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>El joc <a href="https://boardgamegeek.com/boardgame/326235/cronocartes-historia-de-catalunya">Cronocartes Història de Catalunya</a> és un joc de cartes ràpid i familiar en què els jugadors competeixen ordenant una línia cronològica. Està basat en els populars jocs de cartes <a href="https://boardgamegeek.com/boardgame/128664/timeline">Timeline</a> o <a href="https://boardgamegeek.com/boardgame/130882/cardline-animals">Cardline</a>.</p>
<p>El joc és fàcilment portable a altres temes que requereixin una cronologia (moments èpics de la saga <a href="https://boardgamegeek.com/boardgame/183797/timeline-star-wars">Star Wars</a>, història del barri de Sants de Barcelona…). De fet, diverses persones interessades en el format m’han preguntat per consells de com fer una versió del Cronocartes, així que us deixo aquest post amb alguns apunts i consells sobre el disseny per si us poden ser útils.</p>
<!-- more -->
<section id="comença-la-casa-pel-terrat" class="level2">
<h2 class="anchored" data-anchor-id="comença-la-casa-pel-terrat">Comença la casa pel terrat</h2>
<p>No sóc dissenyador gràfic, i una de les pors més grans que tenia era fer un disseny que després hagués d’anar modificant en funció del servei d’impremta. Així que, un cop decidit a fer la versió catalana del Cronocartes, vaig buscar un servei d’impremta que tingués aquestes característiques:</p>
<ul>
<li>Poder tenir un pressupost immediat via web, sense haver d’enviar formularis web, i fer-me una idea ràpida de quan pujaria el cost més important de la producció.</li>
<li>Que oferissin la mateixa mida de cartes que el Timeline per tal de poder-les combinar (Mini USA 41 x 63 mm)</li>
<li>Disponibilitat de descàrrega de la plantilla per fer les cartes.</li>
<li>Format de la plantilla suportat per algun programari lliure (mireu la secció <a href="#eines">Eines</a> avall).</li>
</ul>
<p>La que vaig acabar escollint era <a href="https://www.tipia.es/ludotipia">Ludotipia</a><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, i amb aquesta decisió va quedar fixat:</p>
<ul>
<li>El número total de cartes: <strong>108</strong> (l’aplicatiu web dóna diverses opcions, i aquesta era la més propera a jocs similars)</li>
<li>La <a href="https://www.tipia.es/_files/ugd/f4b6f7_9299a0b3540f404bba309bff86549202.pdf">plantilla</a> per maquetar les cartes, amb tots els marges necessaris. Teniu una imatge de la plantilla abaix tot i que us recomano que treballeu amb el PDF original per que no tingueu sorpreses amb les mides quan genereu els fitxers finals.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="plantilla_tipia.png" class="img-fluid figure-img"></p>
<figcaption>Plantilla Tipia</figcaption>
</figure>
</div>
</section>
<section id="eines" class="level2">
<h2 class="anchored" data-anchor-id="eines">Eines</h2>
<p>Els programes de disseny gràfic com Adobe Photoshop i similars acostumen a estar fora del pressupost dels dissenyadors aficionats, pel que la opció de programari lliure és la opció més econòmica. De fet, són eines que cobreixen amb escreix les tasques que s’han de realitzar. Us passo a continuació una relació de les eines que he utilitzat i l’ús que li he donat:</p>
<ul>
<li><a href="https://www.scribus.net/">Scribus</a> és una aplicatiu d’escriptori per autoedició que he utilitzat per maquetar les cartes. Una de les característiques fonamentals d’aquesta aplicació és que permet fer el que es coneix com a “mail-merge”: generar totes les cartes d’una manera automàtica, ràpida i senzilla a través d’una sola plantilla i un fitxer de text en format Comma Separated Value (CSV) que conté totes les dades de cadascuna de les cartes.</li>
<li><a href="https://www.libreoffice.org/discover/calc/">LibreOffice Calc</a> per editar fulles de càlcul i guardar-les en format CSV. La idea és generar un fitxer en que cada fila contingui títol, any i imatge per cada carta. Amb aquest fitxer i la plantilla de maquetació es poden generar totes les cartes de la baralla (i no haver d’anar muntant les cartes una a una). Al ser fitxers de text, la veritat és que hi han moltes alternatives per editar CSV: si ets programador, pots utilitzar <a href="https://code.visualstudio.com/">VS Code</a> amb l’extensió <a href="https://edit-csv.net">Edit CSV</a>.</li>
<li><a href="https://www.gimp.org/">Gimp</a>, programari lliure d’edició gràfica, indispensable per manipular les imatges (sobretot escalat, rotacions, <em>crop</em>, manipulació de colors i filtrat d’imatges, …)</li>
</ul>
<p>El sistema operatiu que utilitzo és Ubuntu/Linux, però tot aquest programari té versions per altres sistemes operatius.</p>
</section>
<section id="events" class="level2">
<h2 class="anchored" data-anchor-id="events">Events</h2>
<p>Juntament amb la creació de les <a href="#imatges">Imatges</a>, el llistat d’events és el més complicat. Encara que no ho sembli, buscar 100 events històrics que estiguin documentats i més o menys distribuïts en els 2000 anys d’història pot ser complicat. En el cas del Cronocartes Història de Catalunya vaig tenir en compte els següents punts:</p>
<ul>
<li>Volia afegir un punt de complexitat així que la majoria de cartes estan concentrades a finals del segle XIX i principis del XX.</li>
<li>Trobar events del primer mil·leni pot ser un repte per que no hi han gaires referències escrites (a excepció d’events clau com guerres, tractats o revoltes).</li>
<li>Hi ha vegades én que és impossible saber l’any exacte d’un event. En aquests casos podeu posar una <em>c.</em> (del llatí <em>circa</em>, aproximadament) abans de l’any. Una altra alternativa més fàcil d’interpretar pot ser <em>~</em>.</li>
<li>Si us costa trobar la data d’algun event, opteu per posar la primera referència escrita sobre l’event (el cas paradigmàtic del Cronocartes Història de Catalunya és el <em>Mató</em>, sabeu de quin any es té la primera referència? 😜)</li>
<li>L’espai pel text de l’event és reduït (més del que sembla). Haureu de ser creatius per reduir el nombre de caràcters! No dubteu a utilitzar ordinals en comptes de paraules (per exemple <em>1r</em> en comptes de <em>Primer</em>). Algunes vegades he hagut de recórrer a un subtítol (amb un tipus de lletra més petit) en cas que calgués donar una mica més de context, com es mostra en l’exemple que segueix:</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="pont_del_diable.jpeg" class="img-fluid figure-img"></p>
<figcaption>Pont del diable, exemple de subtítol</figcaption>
</figure>
</div>
</section>
<section id="imatges" class="level2">
<h2 class="anchored" data-anchor-id="imatges">Imatges</h2>
<p>Per les imatges de la versió d’Història de Catalunya vaig recórrer a imatges d’internet i alguna composició pròpia. Compteu moltes hores de manipulació d’imatges amb GIMP per acabar d’ajustar-les al format de les cartes. Cal dir que també és una de les parts més creatives del procés, i les possibilitats i eines que dona un programa com GIMP són innumerables.</p>
<p>Arribats a aquest punt, haureu de vigilar amb els <strong>drets d’autor</strong>, especialment si voleu distribuir comercialment el producte. Assegureu-vos que les imatges es poden utilitzar per finalitats comercials. Si teniu dubtes, considereu altres alternatives. En el meu cas, per altres versions estic utilitzant eines d’intel·ligència artificial que a més agilitzen substancialment el procès de creació d’imatges a partir d’un prompt o una altra imatge (o combinació d’imatges). Les eines que he utilitzat són:</p>
<ul>
<li><a href="https://www.krea.ai/">Krea.ai</a>, eina bastant potent que permet generar imatges a partir d’una frase o bé a partir d’altres imatges.</li>
<li><a href="https://clipdrop.co/uncrop">Uncrop</a>, eina que permet estendre una imatge (<em>uncrop</em>) i arribar a una certa resolució o mida. Molt més útil del que pot semblar a simple vista, sobretot per fotografies antigues amb mida reduïda. A baix incloc un exemple on la imatge original (esquerra) s’ha modificat per estendre-la per la part superior i generar un sostre (imatge de la dreta).</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Imatge original</th>
<th style="text-align: left;">Imatge <em>uncropped</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><img src="cuina_economica_org.png" class="img-fluid" alt="original"></td>
<td style="text-align: left;"><img src="cocina_economica.jpeg" class="img-fluid" alt="processada"></td>
</tr>
</tbody>
</table>
<p>Ambdues eines són gratuïtes, però tenen funcionalitat limitada. En el meu cas, els límits d’ús són més que suficients, però m’he plantejat més d’un cop concentrar la feina de modificació d’imatges en un mes i subscriure’m a aquests serveis un parell de mesos per tenir accés a més prestacions que poden ser útils (processat més ràpid i cap limitació en el nombre d’imatges generades, eliminació del fons, …).</p>
</section>
<section id="automatitzant-el-procés" class="level2">
<h2 class="anchored" data-anchor-id="automatitzant-el-procés">Automatitzant el procés</h2>
<p>Fer un joc de taula és un procés iteratiu, pel que cal tenir un mètode que permeti:</p>
<ul>
<li>Regenerar totes les cartes d’una manera ràpida i àgil per tal de poder provar fàcilment vàries opcions de disseny i maquetació.</li>
<li>Tenir un control de les diferents versions que es van fent del mateix. D’aquesta manera tot el procés de creació serà reproduible i traçable.</li>
</ul>
<p>Automatitzar tot el procés garanteix la consistencia en el disseny de tot el joc i evita els “casos especials” que acaben sent un malson quan es va modificant el disseny. Sempre que podeu, intenteu pensar com automatitzar el disseny des del principi de la creació del joc.</p>
<p>Per aquest motiu l’elecció de les eines és critica. Una de les prestacions més important d’Scribus és el fet de poder fer <em>mail-merge</em>: creació de totes les cartes a partir d’una sola plantilla i un CSV amb les dades de totes les cartes. Aquest procés es pot realitzar amb el plug-in <a href="https://berteh.github.io/ScribusGenerator/">Scribus Generator</a>.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>No tinc cap vincle contractual amb ells ni cobro cap mena de comissió o ingrés de publicitat per part seva.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/mgfernan\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>